<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <title>Bản đồ Việt Nam - Thông tin thành phố / phường</title>

    <link rel="stylesheet" href="{{ asset('leaflet/dist/leaflet.css') }}" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />

    <style>
        html,
        body {
            height: 100%;
            margin: 0;
        }

        #map {
            width: 100%;
            height: 100vh;
        }

        .info {
            padding: 6px 8px;
            font: 14px/16px Arial, Helvetica, sans-serif;
            background: white;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        /* coordinate tooltip */
        .coord-tooltip {
            position: fixed;
            left: 12px;
            bottom: 12px;
            background: rgba(255, 255, 255, 0.95);
            color: #222;
            padding: 6px 10px;
            border-radius: 4px;
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.15);
            font-size: 13px;
            font-family: Arial, Helvetica, sans-serif;
            z-index: 1000;
            pointer-events: auto;
        }

        /* right aligned tooltip */
        .coord-tooltip-right {
            left: auto;
            right: 12px;
            text-align: right;
            white-space: pre-line;
        }

        /* filter panel: full-height and wider, scrollable */
        #placeFilter.place-filter {
            position: fixed;
            left: 3px;
            top: 3px;
            bottom: 3px;
            width: 340px;
            height: calc(100vh - 8px);
            overflow-y: auto;
            padding: 12px;
            box-sizing: border-box;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 6px;
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.12);
            font-family: Arial, Helvetica, sans-serif;
            font-size: 13px;
        }

        /* optional nicer thin scrollbar for WebKit browsers */
        #placeFilter.place-filter::-webkit-scrollbar {
            width: 8px;
        }

        #placeFilter.place-filter::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.12);
            border-radius: 4px;
        }

        #placeFilter.place-filter::-webkit-scrollbar-track {
            background: transparent;
        }

        .icon {
            width: 16px;
            height: 16px;
        }
    </style>
</head>

<body>

    <div id="map"></div>

    <!-- coordinate tooltip -->
    <div id="coordTooltip" class="coord-tooltip" style="display:none">Lat: -, Lng: -</div>
    <!-- coordinate tooltip (right) -->
    <div id="coordTooltipRight" class="coord-tooltip coord-tooltip-right" style="display:none">Lat: -, Lng: -</div>

    <!-- legend / filter UI -->
    <div id="placeFilter" class="place-filter">
        <strong style="font-size: 20px; font-family: Times;">Loại địa điểm</strong><br />
        @foreach ($filterTypes as $t)
            <label style="display:block; padding-top:10px">
                <input name="types_id" type="checkbox" value="{{ $t->id }}"><span style="font-size: 20px; font-family: Times;"> {{ $t->name }}</span>
                @if($t->icon)
                    <img src="{{ asset('icons/' . $t->icon) }}" class="icon">
                @endif
            </label><br />
        @endforeach
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

    <script>
        // URL to GeoJSON. Place your file under public/geojson/vn_geo.json
        var geojsonUrl = "{{ asset('geojson/vn_geo.json') }}";

        // initialize map centered on Quảng Ngãi (Quảng Ngãi city area)
        var map = L.map('map').setView([14.805919565207839, 108.925838470459], 13);

        // base layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 33,
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        // info control
        var info = L.control({
            position: 'topright'
        });

        info.onAdd = function(map) {
            this._div = L.DomUtil.create('div', 'info');
            this.update();
            return this._div;
        };

        info.update = function(props) {
            this._div.innerHTML = '<h4>Thông tin hành chính</h4>' + (props ? formatSelectedProps(props) :
            'một khu vực');
        };

        info.addTo(map);

        // style for polygons (thin, light borders)
        function style(feature) {
            return {
                weight: 0.8, // thin border
                opacity: 0.9,
                color: '#cfcfcf', // light gray
                fillOpacity: 0, // transparent fill
                fillColor: 'transparent'
            };
        }

        // highlight on hover (slightly stronger but still subtle)
        function highlightFeature(e) {
            var layer = e.target;

            layer.setStyle({
                weight: 1.6,
                color: '#8f8f8f',
                fillOpacity: 0
            });

            if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                layer.bringToFront();
            }

            info.update(layer.feature.properties);
        }

        function resetHighlight(e) {
            geojsonLayer.resetStyle(e.target);
            info.update();
        }

        function onEachFeature(feature, layer) {
            // bind popup with selected properties only (Tên, Tên cũ)
            var props = feature.properties || {};
            var popupContent = formatSelectedProps(props, true);
            // prevent Leaflet from auto-panning when opening the popup
            layer.bindPopup(popupContent, { autoPan: false });

            layer.on({
                mouseover: highlightFeature,
                mouseout: resetHighlight,
                click: function (e) {
                    // Log the clicked latitude/longitude for this feature
                    console.log('Feature clicked at', e.latlng);
                    // show coordinates in UI tooltip (left)
                    showCoords(e.latlng);
                    // also show coordinates in bottom-right tooltip
                    showCoordsRight(e.latlng);
                    // Open the popup but do not pan the map
                    this.openPopup();
                }
            });
        }

        // Replace generic formatter with a selector that shows only the desired fields
        function formatSelectedProps(props, asHtml) {
            // common property keys to try
            var name = props.name || props.NAME || props.ten || props.TEN || props.name_1 || props.NAME_1 || '';
            var oldName = props.oldName || props.old_name || props.old || props.oldname || props['old name'] || '';

            var lines = [];
            if (name) lines.push('<strong>Tên mới:</strong> ' + escapeHtml(String(name)));
            if (oldName) lines.push('<strong>Tên cũ:</strong> ' + escapeHtml(String(oldName)));
            if (lines.length === 0) lines.push('<em>Không có thông tin tên</em>');

            if (asHtml) return '<div style="max-height:200px;overflow:auto;">' + lines.join('<br/>') + '</div>';
            return lines.join('<br/>');
        }

        function escapeHtml(text) {
            var map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>\"']/g, function(m) {
                return map[m];
            });
        }

        var geojsonLayer = L.geoJSON(null, {
            style: style,
            onEachFeature: onEachFeature
        }).addTo(map);

        // cluster group
        var markersCluster = L.markerClusterGroup();
        map.addLayer(markersCluster);

        // base path for icons (public/icons)
        var iconsBase = "{{ asset('icons') }}";

        // mapping of place_type id => icon filename (from server-side $filterTypes)
        var typeIcons = @json(isset($filterTypes) ? $filterTypes->pluck('icon', 'id') : []);

        // icon factory using public/icons SVGs; prefer per-place `p.icon` when provided
        function iconByType(typeOrId) {
            var defaultUrl = iconsBase + '/marker-green.svg';
            var url = defaultUrl;

            // if numeric id provided, look up in typeIcons mapping
            if (typeOrId !== null && typeOrId !== undefined && String(typeOrId).match(/^\d+$/)) {
                var id = String(typeOrId);
                if (typeIcons && typeIcons[id]) {
                    url = iconsBase + '/' + typeIcons[id];
                }
                return L.icon({
                    iconUrl: url,
                    iconSize: [32, 48],
                    iconAnchor: [16, 48],
                    popupAnchor: [0, -40]
                });
            }

            return L.icon({
                iconUrl: url,
                iconSize: [32, 48],
                iconAnchor: [16, 48],
                popupAnchor: [0, -40]
            });
        }

        // choose icon for a place object; prefer p.icon (filename stored in DB), then type_id mapping
        function iconForPlace(p) {
            try {
                if (p && p.icon) {
                    return L.icon({
                        iconUrl: iconsBase + '/' + p.icon,
                        iconSize: [32, 48],
                        iconAnchor: [16, 48],
                        popupAnchor: [0, -40]
                    });
                }
            } catch (e) {
                console.warn('iconForPlace error', e);
            }

            // prefer type_id (numeric) returned by API
            var typeId = (p && (p.type_id || p.typeId || p.type_id === 0)) ? p.type_id : null;
            if (typeId) return iconByType(typeId);

            // fallback to type_name or legacy type
            var t = (p && p.type_name) ? p.type_name : (p && p.type) ? p.type : null;
            return iconByType(t);
        }

        var loadedPlaces = [];

        function loadPlaces() {
            fetch('/api/places')
                .then(r => r.json())
                .then(data => {
                    loadedPlaces = data;
                    console.log('Loaded places:', loadedPlaces, loadedPlaces.length);
                    renderPlaces();
                }).catch(err => console.error('Load places failed', err));
        }

        function renderPlaces() {
            markersCluster.clearLayers();
            var checked = Array.from(document.querySelectorAll('#placeFilter input[type=checkbox]:checked')).map(function(
            i) {
                return i.value;
            });
            var filterActive = checked.length > 0;
            loadedPlaces.forEach(function(p) {
                var lat = parseFloat(p.lat);
                var lng = parseFloat(p.lng);
                if (isNaN(lat) || isNaN(lng)) return;
                // if filter is active, require type_id match; otherwise show all
                if (filterActive) {
                    // if place has no type_id, still show it
                    if (p.type_id && checked.indexOf(String(p.type_id)) === -1) return; // filtered out by type_id
                }
                var m = L.marker([lat, lng], {
                    icon: iconForPlace(p)
                });
                m.bindPopup(popupForPlace(p), {
                    autoPan: false
                });
                m.on('click', function(e) {
                    showCoords(e.latlng);
                    console.log('Place clicked:', p.id, e.latlng);
                });
                markersCluster.addLayer(m);
            });
        }

        // build popup HTML for a place including thumbnail, time, description
        function popupForPlace(p) {
            var parts = [];
            try {
                if (p.thumbnail) {
                    var url = (String(p.thumbnail).match(/^https?:\/\//)) ? p.thumbnail : (p.thumbnail);
                    parts.push('<div style="text-align:center;margin-bottom:6px;"><img src="' + url +
                        '" style="max-width:230px;max-height:140px;border-radius:6px;display:block;margin:0 auto;"/></div>'
                        );
                }

                parts.push('<div style="font-weight:600;margin-bottom:4px;">' + escapeHtml(p.name || '') + '</div>');

                if (p.time) parts.push('<div style="color:#666;margin-bottom:4px;">Thời gian: <em>' + escapeHtml(p.time) +
                    '</em></div>');

                if (p.address) parts.push('<div>Địa chỉ: ' + escapeHtml(p.address) + '</div>');

                if (p.description) parts.push('<div style="margin-top:6px;color:#333;">Mô tả: ' + escapeHtml(p.description) +
                    '</div>');

                if (p.phone) parts.push('<div style="margin-top:6px;font-size:13px;">Tel: ' + escapeHtml(p.phone) +
                    '</div>');

            } catch (e) {
                console.warn('popupForPlace error', e);
            }
            return '<div style="max-width:260px;line-height:1.25;">' + parts.join('') + '</div>';
        }

        // filter checkbox events
        document.querySelectorAll('#placeFilter input[type=checkbox]').forEach(function(ch) {
            ch.addEventListener('change', function() {
                renderPlaces();
            });
        });

        // initial load
        loadPlaces();

        // Log clicks anywhere on the map (lat, lng)
        map.on('click', function(e) {
            console.log('Map clicked at', e.latlng);
            showCoords(e.latlng);
        });

        // utility to display coordinates in the floating tooltip
        function showCoords(latlng) {
            try {
                var t = document.getElementById('coordTooltip');
                if (!t) return;
                t.style.display = 'block';
                t.textContent = 'Lat: ' + (latlng.lat || latlng.lat === 0 ? latlng.lat.toFixed(6) : '-') + ', Lng: ' + (latlng.lng || latlng.lng === 0 ? latlng.lng.toFixed(6) : '-');
            } catch (e) {
                console.warn('showCoords error', e);
            }
        }

        // utility to display coordinates in bottom-right tooltip
        function showCoordsRight(latlng) {
            try {
                var t = document.getElementById('coordTooltipRight');
                if (!t) return;
                t.style.display = 'block';
                t.textContent = 'Lat: ' + (latlng.lat || latlng.lat === 0 ? latlng.lat.toFixed(6) : '-') + '\nLng: ' + (latlng.lng || latlng.lng === 0 ? latlng.lng.toFixed(6) : '-');
            } catch (e) {
                console.warn('showCoordsRight error', e);
            }
        }

        // load GeoJSON
        fetch(geojsonUrl).then(function(res) {
            if (!res.ok) throw new Error('Không thể tải GeoJSON: ' + res.status);
            return res.json();
        }).then(function(data) {
            geojsonLayer.addData(data);
            // Keep the map centered on Quảng Ngãi. If you want to auto-fit to the GeoJSON bounds,
            // uncomment the following lines:
            // try {
            //     map.fitBounds(geojsonLayer.getBounds());
            // } catch (e) {
            //     console.warn('Không thể fitBounds:', e);
            // }
        }).catch(function(err) {
            console.error(err);
            alert('Lỗi khi tải dữ liệu bản đồ. Vui lòng kiểm tra đường dẫn geojson.');
        });
    </script>

</body>

</html>
